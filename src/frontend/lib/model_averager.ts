import type { EffortGraphSpec } from './effort_graphs';
import { type PlottableModel, PowerXModel } from './plottable_model';
import type { FittedY } from './regression';
import type { Point } from '../../shared/point';

export abstract class ModelAverager {
  abstract addModel(graphSpec: EffortGraphSpec, model: PlottableModel): void;

  abstract getAverageModel(lowestX: number, highestX: number): PlottableModel;

  protected _toWeight(graphSpec: EffortGraphSpec): number {
    const pointCount = graphSpec.points.length;
    const lastX = graphSpec.points[graphSpec.points.length - 1].x;
    return lastX + pointCount;
  }
}

export class PolynomialAverager extends ModelAverager {
  private _baseModel: PlottableModel | null = null;
  private _weightedCoefSums: number[] = [];
  private _totalWeight = 0;

  addModel(graphSpec: EffortGraphSpec, model: PlottableModel): void {
    const coefs = model.regression.jstats.coef;
    const weight = this._toWeight(graphSpec);

    for (let i = 0; i < coefs.length; ++i) {
      if (this._baseModel == null) {
        this._weightedCoefSums[i] = weight * coefs[i];
      } else {
        this._weightedCoefSums[i] += weight * coefs[i];
      }
    }
    this._totalWeight += weight;

    if (!this._baseModel) this._baseModel = model;
  }

  getAverageModel(): PlottableModel {
    // The average of the equations for y can be computed by averaging
    // the coefficients of the terms of the polynomial.
    const baseModel = this._baseModel!;
    for (let i = 0; i < this._weightedCoefSums.length; ++i) {
      baseModel.regression.jstats.coef[i] =
        this._weightedCoefSums[i] / this._totalWeight;
    }
    return baseModel;
  }
}

const AVERAGED_MODEL_POINTS = 20; // shouldn't need very many

interface _ModelInfo {
  fittedY: FittedY;
  weight: number;
}

export class PowerXAverager extends ModelAverager {
  private _baseModel: PlottableModel | null = null;
  private _modelInfos: _ModelInfo[] = [];
  private _totalWeight = 0;

  addModel(graphSpec: EffortGraphSpec, model: PowerXModel): void {
    const weight = this._toWeight(graphSpec);
    this._modelInfos.push({
      fittedY: model.regression.fittedY,
      weight
    });
    this._totalWeight += weight;
    if (!this._baseModel) this._baseModel = model;
  }

  getAverageModel(lowestX: number, highestX: number): PowerXModel {
    // The average of the equations for y cannot be computed from the
    // average of the coefficients, because the power terms have varying
    // exponents. Instead, average the ys generated by the models, and
    // fit a new power model to these points.
    const points: Point[] = [];
    const deltaX = (highestX - lowestX) / AVERAGED_MODEL_POINTS;
    for (let x = lowestX; x <= highestX; x += deltaX) {
      let weightedYSum = 0;
      for (const modelInfo of this._modelInfos) {
        weightedYSum += modelInfo.weight * modelInfo.fittedY(x);
      }
      points.push({ x, y: weightedYSum / this._totalWeight });
    }
    return new PowerXModel(this._baseModel!.hexColor, points);
  }
}
